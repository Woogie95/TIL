시간 복잡도
    - 컴퓨터에서 알고리즘의 시간 복잡도는 입력을 나타내는 문자열 길이의 함수로서 동작하는 알고리즘을 취해 시간을 정량화 하는 것, 이런 시간 복잡도를 표현 하는 방식으로 Big-O 표기법 을 사용
    1. O(1) - 상수 시간 : 입력값이 n 이 주어졌을 때, 연산이 1번만 수행된다. (리터럴 값)
    2. O(log-n) - 로그 시간 : 입력 값이 n이 주어졌을 때, 특정한 요건에 따라 필요한 단계가 연산이 줄어든다. (대표적으로 이진트리)
    3. O(n) - 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1의 관계를 가진다. (n이 커지는 만큼 정직하게 1대1로 정비례하는 듯)
    4. O(n^2) - 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값의 제곱이다.(이중 for문이 있겠다.)
    5. 구구단을 이중 for문으로 구현해봤는데, n이 커질수록 문제해결의 단계수는 n^2로 커진다.
    6. O(C^n) - 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수 C의 n제곱이다.
    - 실행 시간
    - O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n) < O(n!) < O(n^n)

LinkedList
    - 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식의 자료구조입니다. 데이터를 담고 있는 노드들이 연결되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결을 담당
    - 장점 : 데이터 공간을 미리 할당 하지 않아도 됨
    - 단점 :  연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 좋지 않음
    - 연결 정보를 찾는 시간이 오래 걸림으로 접근 속도가 느림
    - 중간 데이터 삭제시, 앞뒤 데이터 연결을 재구성 하는 부가적인 작업 필요

ArrayList
    - ArrayList는 List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형 리스트
    - 일반 배열과 같은 순차리스트이며 인덱스 내부의 객체를 관리 한다는 점등이 유사하지만 한번 생성되면 크기가 변하지 않는 배열과는 달리 ArrayList는 객체들이 추가되어 저장 용량을 초과 한다면 자동으로 부족란 크기만큼 용량이 늘어남
